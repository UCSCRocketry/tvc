'''
This stub is ai generated by chatgpt

This module defines the core propulsion and thrust-vectoring abstractions used
by the rocket simulation. It separates propulsion hardware models, actuators,
and control logic to allow flexible experimentation with different control
strategies while keeping the physics wiring consistent.

Key concepts:
- Motor:
    Abstract base class for thrust-producing devices. Concrete implementations
    (e.g. ElectricFan, RocketMotor) model thrust generation and internal state
    such as throttle or burn time.

- Gimbal:
    Models a two-axis thrust vectoring actuator with angle limits and optional
    rate limiting. Responsible for enforcing physical constraints on commanded
    gimbal angles.

- TVCComponent:
    A physics component that couples a Motor, Gimbal, and controller to apply
    thrust forces and torques to the rocket body each simulation step.
    Controllers are intended to be swappable (PID, LQR, scripted, etc.) without
    modifying the TVCComponent itself.

Design philosophy:
- Controllers compute commands; they do not directly apply forces.
- Actuators (gimbal, motor) enforce physical limits and dynamics.
- TVCComponent acts as the glue between control outputs and rocket physics.
- Assumptions such as perfect measurement or constant thrust are expressed
  through configuration and component choice, not class names.
'''


from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import ClassVar
from enum import Enum

import numpy as np
import rocket_math as rkm
from rocket_math import BidirectionalLookupTable

from physics_component import Component
from rocket import Rocket

sin = np.sin
cos = np.cos


@dataclass
class Motor(ABC): 
        
    @abstractmethod 
    def get_thrust(self) -> float:
        pass 

    @property
    def throttleable(self) -> bool:
        return False

    def set_throttle(self, throttle: float) -> None:
        # Default: ignore (motor has no throttle control)
        pass    

    def step(self, dt: float):
        pass

@dataclass
class SimpleMotor(Motor):
    thrust: float
    duration: float | None = None
    clock : float = 0.0

    def get_thrust(self):
        if self.duration == None:
            return self.thrust
        elif self.clock < self.duration:
            return self.thrust
        else:
            return 0
    
    def step(self, dt):
        self.clock += dt





@dataclass
class ElectricFan(Motor):
    
    '''
        electric fan helper class
        
        throttle_curve: maps throttle (float, 0.0 - 1.0) to thrust (force, newtons)
        throttle: stores throttle (float, 0.0 - 1.0)
    '''

    throttle_curve : BidirectionalLookupTable
    throttle: float = 0.80
    def __post_init__(self):
        self.throttle = rkm.clip(self.throttle, 0.0, 1.0)
    
    @classmethod
    def from_curve_dict(cls, throttle_to_thrust: dict[float, float],throttle: float = 0.80):
        return cls(BidirectionalLookupTable(throttle_to_thrust), throttle)
    
    @property
    def throttleable(self) -> bool:
        return True
    
    def set_throttle(self, throttle : float):
        self.throttle =  rkm.clip(throttle, 0.0, 1.0)
    
    def get_thrust(self) -> float:
        thrust = self.throttle_curve.get_value(self.throttle)
        return thrust

    

@dataclass
class RocketMotor(Motor):
    TYPE = "rocket"
    '''
        simple rocket motor helper class
        assumes perfect rocket motor ignition
        does not store rocket motor mass 
    '''
    def __init__(self, thrust_curve: dict[float, float]):
        self.thrust_curve = BidirectionalLookupTable(thrust_curve)
        self.duration = max(thrust_curve.keys())
        self.burn_time = 0.0
        self.firing = False
        self.spent = False
    
    def get_thrust(self):
        if self.spent:
            return 0.0 
        thrust = self.thrust_curve.get_value(self.burn_time)
        return thrust

    def ignite(self):
        if not self.spent:
            self.firing = True

    def step(self, dt:float):
        if self.burn_time >= self.duration:
            self.firing = False
            self.spent = True 
        if self.firing:
            self.burn_time += dt

@dataclass
class Gimbal:

    def __init__(self, 
                gimbal_limit : tuple[float, float], #gimbal limit (in radians) 
                gimbal_sweep_time :tuple[float, float] = (0.0, 0.0),   #how long it takes for gimbal to go across axis of motion in seconds, where 0 is instantaneous
                gimbal_relative_position :np.ndarray | None = None
        ):

        self.gimbal_limit = np.clip(np.asarray(gimbal_limit, dtype=float), 0.0, None)
        self.gimbal_sweep_time = np.clip(np.asarray(gimbal_sweep_time, dtype=float), 0.0, None)
        self.gimbal_relative_position = np.array([-1,0,0]) if gimbal_relative_position is None else gimbal_relative_position
        
        self.current_gimbal = np.array([0.0, 0.0])
        self.target_gimbal = np.array([0.0, 0.0])
        self.rotation_order = 'yz' # or zy (going outer, inner)

    
    def set_target(self, target : tuple[float, float]):
        targety, targetz = target
        targety = rkm.clip(targety, -self.gimbal_limit[0], self.gimbal_limit[0])
        targetz = rkm.clip(targetz, -self.gimbal_limit[1],self.gimbal_limit[1])

        self.target_gimbal = np.array([targety, targetz])
    
    def get_gimbal(self):
        return self.current_gimbal
    
    def get_target(self):
        return self.target_gimbal

    def get_gimbal_position(self):
        return self.gimbal_relative_position
    
    def set_rotation_order(self, order):
        if order != 'yz' and order != 'zy':
            raise ValueError("rotation order must be either 'yz' or 'zy'")
        else:
            self.rotation_order = order

    
    def get_transformation_matrix(self):
        a, b = self.current_gimbal
        t_y = np.array([[cos(a),  0,  sin(a) ],
                        [0,       1,  0      ],
                        [-sin(a), 0,  cos(a) ]])
        
        t_z = np.array([[cos(b),  -sin(b), 0 ],
                        [sin(b),  cos(b),  0 ],
                        [0,       0,       1 ]])
        #(outer gimbal, inner gimbal)
        if(self.rotation_order == 'yz'):
            return t_y @ t_z
        elif(self.rotation_order == 'zy'):
            return t_z @ t_y


    def step(self, dt:float):
        '''
        gimbal dx where x is angle is: 
        dx = ang_rate * dt 
        ang_rate = gimbal_limit*2 / gimbal_sweep_time
        so: dx = 2 * dt * (gimbal_limit/gimbal_sweep_time)
        '''
        max_dx = 2 * dt * self.gimbal_limit/self.gimbal_sweep_time
        delta_x = self.target_gimbal - self.current_gimbal
        dx = np.clip(delta_x, -max_dx, max_dx)
        
        self.current_gimbal += dx



            
            
            
            




@dataclass
class TVCCommand:
    gimbal_y :float
    gimbal_z :float
    throttle :float 

class TVCController(ABC):    
    @abstractmethod
    def get_command(self, rocket : Rocket, prev_force, prev_moment, dt: float) -> TVCCommand:
        pass

#basic tvc controller with no special features
class Null_TVCController(TVCController):
    def __init__(self, throttle : float = 1.0):
        self.throttle = 1.0 
    
    def get_command(self,rocket,forces, moments,  dt):

        command = TVCCommand(0.0, 0.0, self.throttle)
        return command


    
class TVCComponent(Component):
    def __init__(self, 
                motor: Motor,
                gimbal: Gimbal,
                controller: TVCController
                ):
        self.motor = motor
        self.gimbal = gimbal
        self.controller = controller

        self.prev_force = np.zeros(3)
        self.prev_moment = np.zeros(3)
    
    #runs every tick, apply forces directly to rocket
    def apply(self, rocket, dt):
        #run rocket controller; get packet from controller.
        command = self.controller.get_command(rocket, self.prev_force, self.prev_moment, dt)
        #send commands to components
        self.gimbal.set_target((command.gimbal_y, command.gimbal_z))
        self.motor.set_throttle(command.throttle)
        #calculate forces and moments
        thrust = self.motor.get_thrust()
        force = (self.gimbal.get_transformation_matrix() @ np.array([1,0,0])) * thrust
        #tau = r x v 
        moment = np.cross(self.gimbal.get_gimbal_position(), force)

        self.prev_force, self.prev_moment = force, moment
        #apply forces to rocket
        rocket.applyForceBody(force)
        rocket.applyTorqueBody(moment)

        #increment each component
        self.gimbal.step(dt)
        self.motor.step(dt)
    
    def get_state_data(self):
        return dict()



